use crate::geometry::point::Point3;
use crate::geometry::vec::Vec3;
use crate::utility::float_eq;
use overload::overload;
use std::ops;

/// An interface for entities transformable with a matrix.
///
/// This interface works with 3-dimensional entities (hence the 3 in the name) and thus requires a
/// 4 by 4 matrix in homogeneous coordinates.
pub trait Transform3 {
    /// Transforms a 3D entity with the given 4D matrix.
    /// # Examples
    /// Basic usage:
    /// ```
    /// use glaze::geometry::{Matrix4, Point3, Transform3, Vec3};
    ///
    /// let mov = Vec3::new(0.0, -1.0, 0.0);
    /// let magnitude = Vec3::new(5.0, 1.0, 1.0);
    /// let transform = Matrix4::scale(&magnitude) * Matrix4::translation(&mov);
    /// let original = Point3::new(1.0, 1.0, 1.0);
    /// let transformed = original.transform(&transform);
    ///
    /// assert_eq!(transformed.x, 5.0);
    /// assert_eq!(transformed.y, 0.0);
    /// assert_eq!(transformed.z, 1.0);
    /// ```
    fn transform(&self, mat: &Matrix4) -> Self;
}

//indices for an easier indexing (don't want to use multidimensional array as I don't know the
//memory layout and this will be a really low level class)
const M00: usize = 00;
const M01: usize = 01;
const M02: usize = 02;
const M03: usize = 03;
const M10: usize = 04;
const M11: usize = 05;
const M12: usize = 06;
const M13: usize = 07;
const M20: usize = 08;
const M21: usize = 09;
const M22: usize = 10;
const M23: usize = 11;
const M30: usize = 12;
const M31: usize = 13;
const M32: usize = 14;
const M33: usize = 15;

/// A 4x4 Matrix.
///
/// The Matrix4 class represents a 4x4 transformation matrix in 3D space. A 4x4 Matrix is usually
/// used to perform transformations such as scaling, rotations or translations of a model.
/// The matrix is 4x4 instead of 3x3 because some transformations requires an homogeneous space
/// instead of a cartesian one.
#[derive(Clone)]
pub struct Matrix4 {
    pub(super) m: [f32; 16],
}

impl Matrix4 {
    /// Creates a zero matrix, a matrix where every value is `(0.0)`.
    pub fn zero() -> Matrix4 {
        Matrix4 { m: [0.0; 16] }
    }

    /// Creates an identity matrix.
    ///
    /// The identity matrix is filled with `1.0` values in the diagonal and `0.0` values everywhere
    /// else.
    pub fn identity() -> Matrix4 {
        Matrix4 {
            m: [
                1.0, 0.0, 0.0, 0.0, //
                0.0, 1.0, 0.0, 0.0, //
                0.0, 0.0, 1.0, 0.0, //
                0.0, 0.0, 0.0, 1.0, //
            ],
        }
    }

    /// Creates a matrix with the given values.
    ///
    /// This is intended for debug purposes only, and thus only an array is accepted, as opposed to
    /// a slice.
    #[cfg(test)]
    pub(crate) fn new(values: &[f32; 16]) -> Matrix4 {
        Matrix4 { m: *values }
    }

    /// Creates a transformation matrix representing a translation.
    ///
    /// The input vector `dir` defines the magnitude and direction of the translation.
    /// # Examples
    /// ```
    /// use glaze::geometry::{Matrix4, Point3, Transform3, Vec3};
    ///
    /// let dir = Vec3::new(0.0, 1.0, 0.0);
    /// let translate = Matrix4::translation(&dir);
    /// let original = Point3::zero();
    /// let transformed = original.transform(&translate);
    ///
    /// assert_eq!(transformed.x, 0.0);
    /// assert_eq!(transformed.y, 1.0);
    /// assert_eq!(transformed.z, 0.0);
    /// ```
    pub fn translation(dir: &Vec3) -> Matrix4 {
        Matrix4 {
            m: [
                1.000, 0.000, 0.000, dir.x, //
                0.000, 1.000, 0.000, dir.y, //
                0.000, 0.000, 1.000, dir.z, //
                0.000, 0.000, 0.000, 1.000,
            ],
        }
    }

    /// Extracts the translation component from the matrix.
    ///
    /// If the matrix was generated by a composition of scales, rotations and translations, this
    /// method extracts the translation component.
    /// # Examples
    /// ```
    /// use glaze::geometry::{Matrix4, Vec3};
    ///
    /// let dir = Vec3::new(1.0, 2.0, -3.0);
    /// let translate = Matrix4::translation(&dir);
    /// let extracted = translate.get_translation();
    ///
    /// assert_eq!(extracted.x, dir.x);
    /// assert_eq!(extracted.y, dir.y);
    /// assert_eq!(extracted.z, dir.z);
    /// ```
    pub fn get_translation(&self) -> Vec3 {
        Vec3 {
            x: self.m[M03],
            y: self.m[M13],
            z: self.m[M23],
        }
    }

    /// Creates a transformation matrix representing a scaling.
    ///
    /// The input vector `magnitude` defines the magnitude of the scaling and its component should
    /// be strictly positives.
    /// # Examples
    /// ```
    /// use glaze::geometry::{Matrix4, Point3, Transform3, Vec3};
    ///
    /// let magnitude = Vec3::new(5.0, 1.0, 1.0);
    /// let scale = Matrix4::scale(&magnitude);
    /// let original = Point3::new(1.0, 1.0, 1.0);
    /// let transformed = original.transform(&scale);
    ///
    /// assert_eq!(transformed.x, 5.0);
    /// assert_eq!(transformed.y, 1.0);
    /// assert_eq!(transformed.z, 1.0);
    /// ```
    pub fn scale(magnitude: &Vec3) -> Matrix4 {
        //otherwise fmt refactors the matrix because it's too large with `magnitude`
        //but I want magnitude as the name shown in the signature
        let value = magnitude;
        Matrix4 {
            m: [
                value.x, 0.00000, 0.00000, 0.00000, //
                0.00000, value.y, 0.00000, 0.00000, //
                0.00000, 0.00000, value.z, 0.00000, //
                0.00000, 0.00000, 0.00000, 1.00000, //
            ],
        }
    }

    /// Extracts the scale component from the matrix.
    ///
    /// If the matrix was generated by a composition of scales, rotations and translations, this
    /// method extracts the scale component.
    /// # Examples
    /// ```
    /// use glaze::geometry::{Matrix4, Vec3};
    ///
    /// let magnitude = Vec3::new(1.0, 2.0, 3.0);
    /// let translate = Matrix4::scale(&magnitude);
    /// let extracted = translate.get_scale();
    ///
    /// assert_eq!(extracted.x, magnitude.x);
    /// assert_eq!(extracted.y, magnitude.y);
    /// assert_eq!(extracted.z, magnitude.z);
    /// ```
    pub fn get_scale(&self) -> Vec3 {
        let x = Vec3::new(self.m[M00], self.m[M10], self.m[M20]).length();
        let y = Vec3::new(self.m[M01], self.m[M11], self.m[M21]).length();
        let z = Vec3::new(self.m[M02], self.m[M12], self.m[M22]).length();
        Vec3 { x, y, z }
    }

    /// Creates a rotation matrix around the `x` axis.
    ///
    /// Sets this matrix to a transformation matrix responsible of the rotation around the `x` axis.
    /// This action is also called roll. The input float defines the angle of rotation in *radians*.
    /// # Examples
    /// ```
    /// use assert_approx_eq::assert_approx_eq;
    /// use glaze::geometry::{Matrix4, Point3, Transform3, Vec3};
    ///
    /// let roll = 90.0_f32.to_radians();
    /// let rot = Matrix4::rotate_x(roll);
    /// let original = Point3::new(0.0, 1.0, 0.0);
    /// let transformed = original.transform(&rot);
    ///
    /// assert_approx_eq!(transformed.x, 0.0);
    /// assert_approx_eq!(transformed.y, 0.0);
    /// assert_approx_eq!(transformed.z, 1.0);
    /// ```
    pub fn rotate_x(roll: f32) -> Matrix4 {
        let sint = roll.sin();
        let cost = roll.cos();
        Matrix4 {
            m: [
                1.00, 0.00, 0.00, 0.00, //
                0.00, cost, -sint, 0.00, //
                0.00, sint, cost, 0.00, //
                0.00, 0.00, 0.00, 1.00, //
            ],
        }
    }

    /// Creates a rotation matrix around the `y` axis.
    ///
    /// Sets this matrix to a transformation matrix responsible of the rotation around the `y` axis.
    /// This action is also called pitch. The input float defines the angle of rotation in
    /// *radians*.
    /// # Examples
    /// ```
    /// use assert_approx_eq::assert_approx_eq;
    /// use glaze::geometry::{Matrix4, Point3, Transform3, Vec3};
    ///
    /// let pitch = 90.0_f32.to_radians();
    /// let rot = Matrix4::rotate_y(pitch);
    /// let original = Point3::new(1.0, 0.0, 0.0);
    /// let transformed = original.transform(&rot);
    ///
    /// assert_approx_eq!(transformed.x, 0.0);
    /// assert_approx_eq!(transformed.y, 0.0);
    /// assert_approx_eq!(transformed.z, -1.0);
    /// ```
    pub fn rotate_y(pitch: f32) -> Matrix4 {
        let sint = pitch.sin();
        let cost = pitch.cos();
        Matrix4 {
            m: [
                cost, 0.00, sint, 0.00, //
                0.00, 1.00, 0.00, 0.00, //
                -sint, 0.00, cost, 0.00, //
                0.00, 0.00, 0.00, 1.00, //
            ],
        }
    }

    /// Creates a rotation matrix around the `z` axis.
    ///
    /// Sets this matrix to a transformation matrix responsible of the rotation around the `z` axis.
    /// This action is also called yaw. The input float defines the angle of rotation in *radians*.
    /// # Examples
    /// ```
    /// use assert_approx_eq::assert_approx_eq;
    /// use glaze::geometry::{Matrix4, Point3, Transform3, Vec3};
    ///
    /// let yaw = 90.0_f32.to_radians();
    /// let rot = Matrix4::rotate_z(yaw);
    /// let original = Point3::new(1.0, 0.0, 0.0);
    /// let transformed = original.transform(&rot);
    ///
    /// assert_approx_eq!(transformed.x, 0.0);
    /// assert_approx_eq!(transformed.y, 1.0);
    /// assert_approx_eq!(transformed.z, 0.0);
    /// ```
    pub fn rotate_z(yaw: f32) -> Matrix4 {
        let sint = yaw.sin();
        let cost = yaw.cos();
        Matrix4 {
            m: [
                cost, -sint, 0.00, 0.00, //
                sint, cost, 0.00, 0.00, //
                0.00, 0.00, 1.00, 0.00, //
                0.00, 0.00, 0.00, 1.00, //
            ],
        }
    }

    /// Creates a look-at matrix.
    ///
    /// Sets this matrix to a transformation Look-At matrix in a Left Handed System.
    /// This matrix can then be used to transform coordinates from camera-space to world-space.
    /// In order to obtain a world-space to camera-space transformation, the matrix can be easily
    /// inverted.
    ///
    /// This method takes the following parameters to represent a camera:
    /// - `pos`: The position of the camera in world-space coordinates.
    /// - `target`: The point where the camera is looking at, in world-space coordinates.
    /// - `up`: A unit-vector indicating which direction is the upper side of the camera in
    /// world-space coordinate (used to achieve effects such as camera orientation and angles).
    ///
    /// In camera space, instead, the camera is centered in `(0.0, 0.0, 0.0)`, points towards +z
    /// and has an `up` vector of `(0.0, 1.0, 0.0)`.
    ///
    /// # Panics
    /// If debug assertions are enabled, this method panics if the vector input `up` is not
    /// normalized.
    pub fn camera_to_world(pos: &Point3, target: &Point3, up: &Vec3) -> Matrix4 {
        #[cfg(debug_assertions)]
        {
            if !up.is_normalized() {
                panic!("Creating a camera to world transformation with a non-normalized vector");
            }
        }
        let dir = (target - pos).normalize();
        let right = Vec3::cross(&up, &dir).normalize();
        let newup = Vec3::cross(&dir, &right).normalize();
        Matrix4 {
            m: [
                right.x, newup.x, dir.x, pos.x, //
                right.y, newup.y, dir.y, pos.y, //
                right.z, newup.z, dir.z, pos.z, //
                0.00000, 0.00000, 0.000, 1.000, //
            ],
        }
    }

    /// Returns a new matrix that is the transpose of the current matrix.
    pub fn transpose(&self) -> Matrix4 {
        Matrix4 {
            m: [
                self.m[M00],
                self.m[M10],
                self.m[M20],
                self.m[M30],
                self.m[M01],
                self.m[M11],
                self.m[M21],
                self.m[M31],
                self.m[M02],
                self.m[M12],
                self.m[M22],
                self.m[M32],
                self.m[M03],
                self.m[M13],
                self.m[M23],
                self.m[M33],
            ],
        }
    }

    /// Returns a new matrix that is the inverse of the current matrix.
    /// If the original matrix is not invertible, `None` is returned.
    pub fn inverse(&self) -> Option<Matrix4> {
        let inv00 = self.m[M11] * self.m[M22] * self.m[M33]
            - self.m[M11] * self.m[M23] * self.m[M32]
            - self.m[M21] * self.m[M12] * self.m[M33]
            + self.m[M21] * self.m[M13] * self.m[M32]
            + self.m[M31] * self.m[M12] * self.m[M23]
            - self.m[M31] * self.m[M13] * self.m[M22];

        let inv04 = -self.m[M10] * self.m[M22] * self.m[M33]
            + self.m[M10] * self.m[M23] * self.m[M32]
            + self.m[M20] * self.m[M12] * self.m[M33]
            - self.m[M20] * self.m[M13] * self.m[M32]
            - self.m[M30] * self.m[M12] * self.m[M23]
            + self.m[M30] * self.m[M13] * self.m[M22];

        let inv08 = self.m[M10] * self.m[M21] * self.m[M33]
            - self.m[M10] * self.m[M23] * self.m[M31]
            - self.m[M20] * self.m[M11] * self.m[M33]
            + self.m[M20] * self.m[M13] * self.m[M31]
            + self.m[M30] * self.m[M11] * self.m[M23]
            - self.m[M30] * self.m[M13] * self.m[M21];

        let inv12 = -self.m[M10] * self.m[M21] * self.m[M32]
            + self.m[M10] * self.m[M22] * self.m[M31]
            + self.m[M20] * self.m[M11] * self.m[M32]
            - self.m[M20] * self.m[M12] * self.m[M31]
            - self.m[M30] * self.m[M11] * self.m[M22]
            + self.m[M30] * self.m[M12] * self.m[M21];

        let det =
            self.m[M00] * inv00 + self.m[M01] * inv04 + self.m[M02] * inv08 + self.m[M03] * inv12;

        if float_eq(det, 0.0, 1E-5) {
            return None;
        }

        let inv01 = -self.m[M01] * self.m[M22] * self.m[M33]
            + self.m[M01] * self.m[M23] * self.m[M32]
            + self.m[M21] * self.m[M02] * self.m[M33]
            - self.m[M21] * self.m[M03] * self.m[M32]
            - self.m[M31] * self.m[M02] * self.m[M23]
            + self.m[M31] * self.m[M03] * self.m[M22];

        let inv05 = self.m[M00] * self.m[M22] * self.m[M33]
            - self.m[M00] * self.m[M23] * self.m[M32]
            - self.m[M20] * self.m[M02] * self.m[M33]
            + self.m[M20] * self.m[M03] * self.m[M32]
            + self.m[M30] * self.m[M02] * self.m[M23]
            - self.m[M30] * self.m[M03] * self.m[M22];

        let inv09 = -self.m[M00] * self.m[M21] * self.m[M33]
            + self.m[M00] * self.m[M23] * self.m[M31]
            + self.m[M20] * self.m[M01] * self.m[M33]
            - self.m[M20] * self.m[M03] * self.m[M31]
            - self.m[M30] * self.m[M01] * self.m[M23]
            + self.m[M30] * self.m[M03] * self.m[M21];

        let inv13 = self.m[M00] * self.m[M21] * self.m[M32]
            - self.m[M00] * self.m[M22] * self.m[M31]
            - self.m[M20] * self.m[M01] * self.m[M32]
            + self.m[M20] * self.m[M02] * self.m[M31]
            + self.m[M30] * self.m[M01] * self.m[M22]
            - self.m[M30] * self.m[M02] * self.m[M21];

        let inv02 = self.m[M01] * self.m[M12] * self.m[M33]
            - self.m[M01] * self.m[M13] * self.m[M32]
            - self.m[M11] * self.m[M02] * self.m[M33]
            + self.m[M11] * self.m[M03] * self.m[M32]
            + self.m[M31] * self.m[M02] * self.m[M13]
            - self.m[M31] * self.m[M03] * self.m[M12];

        let inv06 = -self.m[M00] * self.m[M12] * self.m[M33]
            + self.m[M00] * self.m[M13] * self.m[M32]
            + self.m[M10] * self.m[M02] * self.m[M33]
            - self.m[M10] * self.m[M03] * self.m[M32]
            - self.m[M30] * self.m[M02] * self.m[M13]
            + self.m[M30] * self.m[M03] * self.m[M12];

        let inv10 = self.m[M00] * self.m[M11] * self.m[M33]
            - self.m[M00] * self.m[M13] * self.m[M31]
            - self.m[M10] * self.m[M01] * self.m[M33]
            + self.m[M10] * self.m[M03] * self.m[M31]
            + self.m[M30] * self.m[M01] * self.m[M13]
            - self.m[M30] * self.m[M03] * self.m[M11];

        let inv14 = -self.m[M00] * self.m[M11] * self.m[M32]
            + self.m[M00] * self.m[M12] * self.m[M31]
            + self.m[M10] * self.m[M01] * self.m[M32]
            - self.m[M10] * self.m[M02] * self.m[M31]
            - self.m[M30] * self.m[M01] * self.m[M12]
            + self.m[M30] * self.m[M02] * self.m[M11];

        let inv03 = -self.m[M01] * self.m[M12] * self.m[M23]
            + self.m[M01] * self.m[M13] * self.m[M22]
            + self.m[M11] * self.m[M02] * self.m[M23]
            - self.m[M11] * self.m[M03] * self.m[M22]
            - self.m[M21] * self.m[M02] * self.m[M13]
            + self.m[M21] * self.m[M03] * self.m[M12];

        let inv07 = self.m[M00] * self.m[M12] * self.m[M23]
            - self.m[M00] * self.m[M13] * self.m[M22]
            - self.m[M10] * self.m[M02] * self.m[M23]
            + self.m[M10] * self.m[M03] * self.m[M22]
            + self.m[M20] * self.m[M02] * self.m[M13]
            - self.m[M20] * self.m[M03] * self.m[M12];

        let inv11 = -self.m[M00] * self.m[M11] * self.m[M23]
            + self.m[M00] * self.m[M13] * self.m[M21]
            + self.m[M10] * self.m[M01] * self.m[M23]
            - self.m[M10] * self.m[M03] * self.m[M21]
            - self.m[M20] * self.m[M01] * self.m[M13]
            + self.m[M20] * self.m[M03] * self.m[M11];

        let inv15 = self.m[M00] * self.m[M11] * self.m[M22]
            - self.m[M00] * self.m[M12] * self.m[M21]
            - self.m[M10] * self.m[M01] * self.m[M22]
            + self.m[M10] * self.m[M02] * self.m[M21]
            + self.m[M20] * self.m[M01] * self.m[M12]
            - self.m[M20] * self.m[M02] * self.m[M11];

        let invdet = 1.0 / det;
        Some(Matrix4 {
            m: [
                inv00 * invdet,
                inv01 * invdet,
                inv02 * invdet,
                inv03 * invdet,
                inv04 * invdet,
                inv05 * invdet,
                inv06 * invdet,
                inv07 * invdet,
                inv08 * invdet,
                inv09 * invdet,
                inv10 * invdet,
                inv11 * invdet,
                inv12 * invdet,
                inv13 * invdet,
                inv14 * invdet,
                inv15 * invdet,
            ],
        })
    }
}

overload!((a: ?Matrix4) + (b: ?Matrix4) -> Matrix4 {
Matrix4{
    m: [
    a.m[M00]+b.m[M00], a.m[M01]+b.m[M01], a.m[M02]+b.m[M02], a.m[M03]+b.m[M03],
    a.m[M10]+b.m[M10], a.m[M11]+b.m[M11], a.m[M12]+b.m[M12], a.m[M13]+b.m[M13],
    a.m[M20]+b.m[M20], a.m[M21]+b.m[M21], a.m[M22]+b.m[M22], a.m[M23]+b.m[M23],
    a.m[M30]+b.m[M30], a.m[M31]+b.m[M31], a.m[M32]+b.m[M32], a.m[M33]+b.m[M33],
    ]}}
    );

overload!((a: ?Matrix4) - (b: ?Matrix4) -> Matrix4 {
Matrix4{
    m: [
    a.m[M00]-b.m[M00], a.m[M01]-b.m[M01], a.m[M02]-b.m[M02], a.m[M03]-b.m[M03],
    a.m[M10]-b.m[M10], a.m[M11]-b.m[M11], a.m[M12]-b.m[M12], a.m[M13]-b.m[M13],
    a.m[M20]-b.m[M20], a.m[M21]-b.m[M21], a.m[M22]-b.m[M22], a.m[M23]-b.m[M23],
    a.m[M30]-b.m[M30], a.m[M31]-b.m[M31], a.m[M32]-b.m[M32], a.m[M33]-b.m[M33],
    ]}}
    );

overload!((a: ?Matrix4) * (b: ?Matrix4) -> Matrix4 {
 Matrix4 {
 m: [
    (a.m[M00]*b.m[M00])+(a.m[M01]*b.m[M10])+(a.m[M02]*b.m[M20])+(a.m[M03]*b.m[M30]),
    (a.m[M00]*b.m[M01])+(a.m[M01]*b.m[M11])+(a.m[M02]*b.m[M21])+(a.m[M03]*b.m[M31]),
    (a.m[M00]*b.m[M02])+(a.m[M01]*b.m[M12])+(a.m[M02]*b.m[M22])+(a.m[M03]*b.m[M32]),
    (a.m[M00]*b.m[M03])+(a.m[M01]*b.m[M13])+(a.m[M02]*b.m[M23])+(a.m[M03]*b.m[M33]),
    (a.m[M10]*b.m[M00])+(a.m[M11]*b.m[M10])+(a.m[M12]*b.m[M20])+(a.m[M13]*b.m[M30]),
    (a.m[M10]*b.m[M01])+(a.m[M11]*b.m[M11])+(a.m[M12]*b.m[M21])+(a.m[M13]*b.m[M31]),
    (a.m[M10]*b.m[M02])+(a.m[M11]*b.m[M12])+(a.m[M12]*b.m[M22])+(a.m[M13]*b.m[M32]),
    (a.m[M10]*b.m[M03])+(a.m[M11]*b.m[M13])+(a.m[M12]*b.m[M23])+(a.m[M13]*b.m[M33]),
    (a.m[M20]*b.m[M00])+(a.m[M21]*b.m[M10])+(a.m[M22]*b.m[M20])+(a.m[M23]*b.m[M30]),
    (a.m[M20]*b.m[M01])+(a.m[M21]*b.m[M11])+(a.m[M22]*b.m[M21])+(a.m[M23]*b.m[M31]),
    (a.m[M20]*b.m[M02])+(a.m[M21]*b.m[M12])+(a.m[M22]*b.m[M22])+(a.m[M23]*b.m[M32]),
    (a.m[M20]*b.m[M03])+(a.m[M21]*b.m[M13])+(a.m[M22]*b.m[M23])+(a.m[M23]*b.m[M33]),
    (a.m[M30]*b.m[M00])+(a.m[M31]*b.m[M10])+(a.m[M32]*b.m[M20])+(a.m[M33]*b.m[M30]),
    (a.m[M30]*b.m[M01])+(a.m[M31]*b.m[M11])+(a.m[M32]*b.m[M21])+(a.m[M33]*b.m[M31]),
    (a.m[M30]*b.m[M02])+(a.m[M31]*b.m[M12])+(a.m[M32]*b.m[M22])+(a.m[M33]*b.m[M32]),
    (a.m[M30]*b.m[M03])+(a.m[M31]*b.m[M13])+(a.m[M32]*b.m[M23])+(a.m[M33]*b.m[M33]),
    ]}}
);

overload!((a: &mut Matrix4) += (b: ?Matrix4) {
a.m[M00]+=b.m[M00]; a.m[M01]+=b.m[M01]; a.m[M02]+=b.m[M02]; a.m[M03]+=b.m[M03];
a.m[M10]+=b.m[M10]; a.m[M11]+=b.m[M11]; a.m[M12]+=b.m[M12]; a.m[M13]+=b.m[M13];
a.m[M20]+=b.m[M20]; a.m[M21]+=b.m[M21]; a.m[M22]+=b.m[M22]; a.m[M23]+=b.m[M23];
a.m[M30]+=b.m[M30]; a.m[M31]+=b.m[M31]; a.m[M32]+=b.m[M32]; a.m[M33]+=b.m[M33];
});

overload!((a: &mut Matrix4) -= (b: ?Matrix4) {
a.m[M00]-=b.m[M00]; a.m[M01]-=b.m[M01]; a.m[M02]-=b.m[M02]; a.m[M03]-=b.m[M03];
a.m[M10]-=b.m[M10]; a.m[M11]-=b.m[M11]; a.m[M12]-=b.m[M12]; a.m[M13]-=b.m[M13];
a.m[M20]-=b.m[M20]; a.m[M21]-=b.m[M21]; a.m[M22]-=b.m[M22]; a.m[M23]-=b.m[M23];
a.m[M30]-=b.m[M30]; a.m[M31]-=b.m[M31]; a.m[M32]-=b.m[M32]; a.m[M33]-=b.m[M33];
});

overload!((a: &mut Matrix4) *= (b: ?Matrix4) {
let m00=(a.m[M00]*b.m[M00])+(a.m[M01]*b.m[M10])+(a.m[M02]*b.m[M20])+(a.m[M03]*b.m[M30]);
let m01=(a.m[M00]*b.m[M01])+(a.m[M01]*b.m[M11])+(a.m[M02]*b.m[M21])+(a.m[M03]*b.m[M31]);
let m02=(a.m[M00]*b.m[M02])+(a.m[M01]*b.m[M12])+(a.m[M02]*b.m[M22])+(a.m[M03]*b.m[M32]);
let m03=(a.m[M00]*b.m[M03])+(a.m[M01]*b.m[M13])+(a.m[M02]*b.m[M23])+(a.m[M03]*b.m[M33]);
let m04=(a.m[M10]*b.m[M00])+(a.m[M11]*b.m[M10])+(a.m[M12]*b.m[M20])+(a.m[M13]*b.m[M30]);
let m05=(a.m[M10]*b.m[M01])+(a.m[M11]*b.m[M11])+(a.m[M12]*b.m[M21])+(a.m[M13]*b.m[M31]);
let m06=(a.m[M10]*b.m[M02])+(a.m[M11]*b.m[M12])+(a.m[M12]*b.m[M22])+(a.m[M13]*b.m[M32]);
let m07=(a.m[M10]*b.m[M03])+(a.m[M11]*b.m[M13])+(a.m[M12]*b.m[M23])+(a.m[M13]*b.m[M33]);
let m08=(a.m[M20]*b.m[M00])+(a.m[M21]*b.m[M10])+(a.m[M22]*b.m[M20])+(a.m[M23]*b.m[M30]);
let m09=(a.m[M20]*b.m[M01])+(a.m[M21]*b.m[M11])+(a.m[M22]*b.m[M21])+(a.m[M23]*b.m[M31]);
let m10=(a.m[M20]*b.m[M02])+(a.m[M21]*b.m[M12])+(a.m[M22]*b.m[M22])+(a.m[M23]*b.m[M32]);
let m11=(a.m[M20]*b.m[M03])+(a.m[M21]*b.m[M13])+(a.m[M22]*b.m[M23])+(a.m[M23]*b.m[M33]);
let m12=(a.m[M30]*b.m[M00])+(a.m[M31]*b.m[M10])+(a.m[M32]*b.m[M20])+(a.m[M33]*b.m[M30]);
let m13=(a.m[M30]*b.m[M01])+(a.m[M31]*b.m[M11])+(a.m[M32]*b.m[M21])+(a.m[M33]*b.m[M31]);
let m14=(a.m[M30]*b.m[M02])+(a.m[M31]*b.m[M12])+(a.m[M32]*b.m[M22])+(a.m[M33]*b.m[M32]);
let m15=(a.m[M30]*b.m[M03])+(a.m[M31]*b.m[M13])+(a.m[M32]*b.m[M23])+(a.m[M33]*b.m[M33]);
a.m[00]=m00;a.m[01]=m01;a.m[02]=m02;a.m[03]=m03;a.m[04]=m04;a.m[05]=m05;a.m[06]=m06;a.m[07]=m07;
a.m[08]=m08;a.m[09]=m09;a.m[10]=m10;a.m[11]=m11;a.m[12]=m12;a.m[13]=m13;a.m[14]=m14;a.m[15]=m15;
});

#[cfg(test)]
mod tests {
    use crate::geometry::{Matrix4, Point3, Vec3};
    use assert_approx_eq::assert_approx_eq;

    #[test]
    fn matrix4_new() {
        let vals = [
            0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0,
        ];
        let m = Matrix4::new(&vals);
        assert_eq!(m.m[00], vals[0]);
        assert_eq!(m.m[01], vals[1]);
        assert_eq!(m.m[02], vals[2]);
        assert_eq!(m.m[03], vals[3]);
        assert_eq!(m.m[04], vals[4]);
        assert_eq!(m.m[05], vals[5]);
        assert_eq!(m.m[06], vals[6]);
        assert_eq!(m.m[07], vals[7]);
        assert_eq!(m.m[08], vals[8]);
        assert_eq!(m.m[09], vals[9]);
        assert_eq!(m.m[10], vals[10]);
        assert_eq!(m.m[11], vals[11]);
        assert_eq!(m.m[12], vals[12]);
        assert_eq!(m.m[13], vals[13]);
        assert_eq!(m.m[14], vals[14]);
        assert_eq!(m.m[15], vals[15]);
    }

    #[test]
    fn matrix4_set_zero() {
        let m = Matrix4::zero();
        assert_eq!(m.m[00], 0.0);
        assert_eq!(m.m[01], 0.0);
        assert_eq!(m.m[02], 0.0);
        assert_eq!(m.m[03], 0.0);
        assert_eq!(m.m[04], 0.0);
        assert_eq!(m.m[05], 0.0);
        assert_eq!(m.m[06], 0.0);
        assert_eq!(m.m[07], 0.0);
        assert_eq!(m.m[08], 0.0);
        assert_eq!(m.m[09], 0.0);
        assert_eq!(m.m[10], 0.0);
        assert_eq!(m.m[11], 0.0);
        assert_eq!(m.m[12], 0.0);
        assert_eq!(m.m[13], 0.0);
        assert_eq!(m.m[14], 0.0);
        assert_eq!(m.m[15], 0.0);
    }

    #[test]
    fn matrix4_set_identity() {
        let m = Matrix4::identity();
        assert_eq!(m.m[00], 1.0);
        assert_eq!(m.m[01], 0.0);
        assert_eq!(m.m[02], 0.0);
        assert_eq!(m.m[03], 0.0);
        assert_eq!(m.m[04], 0.0);
        assert_eq!(m.m[05], 1.0);
        assert_eq!(m.m[06], 0.0);
        assert_eq!(m.m[07], 0.0);
        assert_eq!(m.m[08], 0.0);
        assert_eq!(m.m[09], 0.0);
        assert_eq!(m.m[10], 1.0);
        assert_eq!(m.m[11], 0.0);
        assert_eq!(m.m[12], 0.0);
        assert_eq!(m.m[13], 0.0);
        assert_eq!(m.m[14], 0.0);
        assert_eq!(m.m[15], 1.0);
    }

    #[test]
    fn matrix4_set_translation() {
        let dir = Vec3::new(-87.39175, 8.35182, -93.43325);
        let m = Matrix4::translation(&dir);
        assert_eq!(m.m[00], 1.0);
        assert_eq!(m.m[01], 0.0);
        assert_eq!(m.m[02], 0.0);
        assert_eq!(m.m[03], dir.x);
        assert_eq!(m.m[04], 0.0);
        assert_eq!(m.m[05], 1.0);
        assert_eq!(m.m[06], 0.0);
        assert_eq!(m.m[07], dir.y);
        assert_eq!(m.m[08], 0.0);
        assert_eq!(m.m[09], 0.0);
        assert_eq!(m.m[10], 1.0);
        assert_eq!(m.m[11], dir.z);
        assert_eq!(m.m[12], 0.0);
        assert_eq!(m.m[13], 0.0);
        assert_eq!(m.m[14], 0.0);
        assert_eq!(m.m[15], 1.0);
    }

    #[test]
    fn matrix4_set_scale_non_uniform() {
        let magnitude = Vec3::new(41.24096, -93.12313, 31.83295);
        let m = Matrix4::scale(&magnitude);
        assert_eq!(m.m[00], magnitude.x);
        assert_eq!(m.m[01], 0.0);
        assert_eq!(m.m[02], 0.0);
        assert_eq!(m.m[03], 0.0);
        assert_eq!(m.m[04], 0.0);
        assert_eq!(m.m[05], magnitude.y);
        assert_eq!(m.m[06], 0.0);
        assert_eq!(m.m[07], 0.0);
        assert_eq!(m.m[08], 0.0);
        assert_eq!(m.m[09], 0.0);
        assert_eq!(m.m[10], magnitude.z);
        assert_eq!(m.m[11], 0.0);
        assert_eq!(m.m[12], 0.0);
        assert_eq!(m.m[13], 0.0);
        assert_eq!(m.m[14], 0.0);
        assert_eq!(m.m[15], 1.0);
    }

    #[test]
    fn matrix4_set_rotate_x() {
        let roll = 3.0 / 4.0 * std::f32::consts::PI;
        let m = Matrix4::rotate_x(roll);
        assert_approx_eq!(m.m[00], 1.0);
        assert_approx_eq!(m.m[01], 0.0);
        assert_approx_eq!(m.m[02], 0.0);
        assert_approx_eq!(m.m[03], 0.0);
        assert_approx_eq!(m.m[04], 0.0);
        assert_approx_eq!(m.m[05], -1.0 / (2.0_f32).sqrt(), 1e-5);
        assert_approx_eq!(m.m[06], -1.0 / (2.0_f32).sqrt(), 1e-5);
        assert_approx_eq!(m.m[07], 0.0);
        assert_approx_eq!(m.m[08], 0.0);
        assert_approx_eq!(m.m[09], 1.0 / (2.0_f32).sqrt(), 1e-5);
        assert_approx_eq!(m.m[10], -1.0 / (2.0_f32).sqrt(), 1e-5);
        assert_approx_eq!(m.m[11], 0.0);
        assert_approx_eq!(m.m[12], 0.0);
        assert_approx_eq!(m.m[13], 0.0);
        assert_approx_eq!(m.m[14], 0.0);
        assert_approx_eq!(m.m[15], 1.0);
    }

    #[test]
    fn matrix4_set_rotate_y() {
        let pitch = 3.0 / 4.0 * std::f32::consts::PI;
        let m = Matrix4::rotate_y(pitch);
        assert_approx_eq!(m.m[00], -1.0 / (2.0_f32).sqrt(), 1e-5);
        assert_approx_eq!(m.m[01], 0.0);
        assert_approx_eq!(m.m[02], 1.0 / (2.0_f32).sqrt(), 1e-5);
        assert_approx_eq!(m.m[03], 0.0);
        assert_approx_eq!(m.m[04], 0.0);
        assert_approx_eq!(m.m[05], 1.0);
        assert_approx_eq!(m.m[06], 0.0);
        assert_approx_eq!(m.m[07], 0.0);
        assert_approx_eq!(m.m[08], -1.0 / (2.0_f32).sqrt(), 1e-5);
        assert_approx_eq!(m.m[09], 0.0);
        assert_approx_eq!(m.m[10], -1.0 / (2.0_f32).sqrt(), 1e-5);
        assert_approx_eq!(m.m[11], 0.0);
        assert_approx_eq!(m.m[12], 0.0);
        assert_approx_eq!(m.m[13], 0.0);
        assert_approx_eq!(m.m[14], 0.0);
        assert_approx_eq!(m.m[15], 1.0);
    }

    #[test]
    fn matrix4_set_rotate_z() {
        let yaw = 3.0 / 4.0 * std::f32::consts::PI;
        let m = Matrix4::rotate_z(yaw);
        assert_approx_eq!(m.m[00], -1.0 / (2.0_f32).sqrt(), 1e-5);
        assert_approx_eq!(m.m[01], -1.0 / (2.0_f32).sqrt(), 1e-5);
        assert_approx_eq!(m.m[02], 0.0);
        assert_approx_eq!(m.m[03], 0.0);
        assert_approx_eq!(m.m[04], 1.0 / (2.0_f32).sqrt(), 1e-5);
        assert_approx_eq!(m.m[05], -1.0 / (2.0_f32).sqrt(), 1e-5);
        assert_approx_eq!(m.m[06], 0.0);
        assert_approx_eq!(m.m[07], 0.0);
        assert_approx_eq!(m.m[08], 0.0);
        assert_approx_eq!(m.m[09], 0.0);
        assert_approx_eq!(m.m[10], 1.0);
        assert_approx_eq!(m.m[11], 0.0);
        assert_approx_eq!(m.m[12], 0.0);
        assert_approx_eq!(m.m[13], 0.0);
        assert_approx_eq!(m.m[14], 0.0);
        assert_approx_eq!(m.m[15], 1.0);
    }

    #[test]
    #[should_panic]
    fn matrix4_camera_to_world_not_normalized() {
        let up = Vec3::new(1.0, 1.0, 0.0);
        let pos = Point3::new(1.0, 0.0, -2.0);
        let target = Point3::new(0.0, 0.0, 1.0);
        let _m = Matrix4::camera_to_world(&pos, &target, &up);
    }

    #[test]
    fn matrix4_camera_to_world() {
        let up = Vec3::new(1.0, 1.0, 0.0).normalize();
        let pos = Point3::new(1.0, 0.0, -2.0);
        let target = Point3::new(0.0, 0.0, 1.0);
        let m = Matrix4::camera_to_world(&pos, &target, &up);

        assert_approx_eq!(m.m[00], 0.688247144, 1e-5);
        assert_approx_eq!(m.m[01], 0.65292853, 1e-5);
        assert_approx_eq!(m.m[02], -0.31622776, 1e-5);
        assert_approx_eq!(m.m[03], 1.0, 1e-5);
        assert_approx_eq!(m.m[04], -0.688247, 1e-5);
        assert_approx_eq!(m.m[05], 0.725476, 1e-5);
        assert_approx_eq!(m.m[06], 0.0, 1e-5);
        assert_approx_eq!(m.m[07], 0.0, 1e-5);
        assert_approx_eq!(m.m[08], 0.22941573, 1e-5);
        assert_approx_eq!(m.m[09], 0.21764286, 1e-5);
        assert_approx_eq!(m.m[10], 0.948683261, 1e-5);
        assert_approx_eq!(m.m[11], -2.0, 1e-5);
        assert_approx_eq!(m.m[12], 0.0, 1e-5);
        assert_approx_eq!(m.m[13], 0.0, 1e-5);
        assert_approx_eq!(m.m[14], 0.0, 1e-5);
        assert_approx_eq!(m.m[15], 1.0, 1e-5);
    }

    #[test]
    fn matrix4_transpose() {
        let vals = [
            27.9484, -88.37513, -25.05486, 0.93192, 19.53558, 55.46225, -92.99693, 13.30983,
            -39.91206, -63.35516, -80.28301, 96.89149, -97.99183, 69.73036, 34.27019, 58.81281,
        ];
        let m = Matrix4::new(&vals);
        let out = m.transpose();
        assert_eq!(vals[00], out.m[00]);
        assert_eq!(vals[01], out.m[04]);
        assert_eq!(vals[02], out.m[08]);
        assert_eq!(vals[03], out.m[12]);
        assert_eq!(vals[04], out.m[01]);
        assert_eq!(vals[05], out.m[05]);
        assert_eq!(vals[06], out.m[09]);
        assert_eq!(vals[07], out.m[13]);
        assert_eq!(vals[08], out.m[02]);
        assert_eq!(vals[09], out.m[06]);
        assert_eq!(vals[10], out.m[10]);
        assert_eq!(vals[11], out.m[14]);
        assert_eq!(vals[12], out.m[03]);
        assert_eq!(vals[13], out.m[07]);
        assert_eq!(vals[14], out.m[11]);
        assert_eq!(vals[15], out.m[15]);
    }

    #[test]
    fn matrix4_transform() {
        //    Point3 p(1.0,0.0,0.0);
        //    let translate = Vec3::new(0.0, 0.0, 0.0);
        //    let rotate = Vec3::new(0.0, radians(90.0), 0.0);
        //    let scale = Vec3::new(1.0);
        //
        //    Matrix4 transform;
        //    transform.set_transform(translate,rotate,scale);
        //
        //    Point3 res = transform*p;
        //    assert_approx_eq!(res.x, 0.0, 1e-5);
        //    assert_approx_eq!(res.y, 3.5, 1e-5);
        //    assert_approx_eq!(res.z, 0.0, 1e-5);
    }

    #[test]
    fn matrix4_inverse_invertible() {
        //invertible
        let vals = [
            44.48, -69.73, 62.26, -89.47, -20.59, 45.01, -77.12, 21.26, 3.27, 42.29, -62.23,
            -49.23, 6.83, -80.83, 18.96, -84.16,
        ];
        let m = Matrix4::new(&vals).inverse().unwrap();
        assert_approx_eq!(m.m[00], 0.056968, 1e-5);
        assert_approx_eq!(m.m[01], 0.060421, 1e-5);
        assert_approx_eq!(m.m[02], -0.026891, 1e-5);
        assert_approx_eq!(m.m[03], -0.029569, 1e-5);
        assert_approx_eq!(m.m[04], -0.016213, 1e-5);
        assert_approx_eq!(m.m[05], -0.032876, 1e-5);
        assert_approx_eq!(m.m[06], 0.023122, 1e-5);
        assert_approx_eq!(m.m[07], -0.004594, 1e-5);
        assert_approx_eq!(m.m[08], -0.020370, 1e-5);
        assert_approx_eq!(m.m[09], -0.040761, 1e-5);
        assert_approx_eq!(m.m[10], 0.014874, 1e-5);
        assert_approx_eq!(m.m[11], 0.002657, 1e-5);
        assert_approx_eq!(m.m[12], 0.015605, 1e-5);
        assert_approx_eq!(m.m[13], 0.027296, 1e-5);
        assert_approx_eq!(m.m[14], -0.021038, 1e-5);
        assert_approx_eq!(m.m[15], -0.009270, 1e-5);
    }

    #[test]
    fn matrix4_inverse_non_invertible() {
        let m = Matrix4::zero().inverse();
        assert!(m.is_none());
    }

    #[test]
    fn matrix4_get_translation() {
        let scale = Vec3::new(53.94708, -56.04181, 38.21224);
        let translation = Vec3::new(-5.28423, 22.63478, 22.10424);
        let rotation = Vec3::new(-0.07627, -31.31443, -88.95238);
        let ms = Matrix4::scale(&scale);
        let mt = Matrix4::translation(&translation);
        let mrx = Matrix4::rotate_x(rotation.x);
        let mry = Matrix4::rotate_y(rotation.y);
        let mrz = Matrix4::rotate_z(rotation.z);
        let mut combined = Matrix4::identity();

        combined *= mt;
        combined *= mrz;
        combined *= mry;
        combined *= mrx;
        combined *= ms;

        let extracted = combined.get_translation();
        assert_approx_eq!(extracted.x, translation.x, 1e-5);
        assert_approx_eq!(extracted.y, translation.y, 1e-5);
        assert_approx_eq!(extracted.z, translation.z, 1e-5);
    }

    #[test]
    fn matrix4_get_scale() {
        let scale = Vec3::new(37.99025, 69.85438, 5.79172);
        let translation = Vec3::new(-17.90241, 37.90712, 74.85354);
        let rotation = Vec3::new(-20.80442, 27.33369, -31.58807);
        let ms = Matrix4::scale(&scale);
        let mt = Matrix4::translation(&translation);
        let mrx = Matrix4::rotate_x(rotation.x);
        let mry = Matrix4::rotate_y(rotation.y);
        let mrz = Matrix4::rotate_z(rotation.z);
        let mut combined = Matrix4::identity();

        combined *= mt;
        combined *= mrz;
        combined *= mry;
        combined *= mrx;
        combined *= ms;

        let extracted = combined.get_scale();
        assert_approx_eq!(extracted.x, scale.x, 1e-5);
        assert_approx_eq!(extracted.y, scale.y, 1e-5);
        assert_approx_eq!(extracted.z, scale.z, 1e-5);
    }

    #[test]
    fn matrix4_add() {
        let val1 = [
            -98.96, 98.99, 72.96, 98.37, -61.17, 6.0, -13.05, 18.62, 43.24, -19.56, 39.17, -19.17,
            -49.98, -36.64, 48.0, 45.27,
        ];
        let val2 = [
            59.09, -8.73, -19.45, 88.6, 85.6, -67.18, 31.89, -71.7, 40.15, 38.28, 48.01, -73.72,
            37.04, 34.6, -46.98, -44.3,
        ];
        let m1 = Matrix4::new(&val1);
        let m2 = Matrix4::new(&val2);
        let out = m1 + m2;
        assert_approx_eq!(out.m[00], -39.87, 1e-5);
        assert_approx_eq!(out.m[01], 90.26, 1e-5);
        assert_approx_eq!(out.m[02], 53.51, 1e-5);
        assert_approx_eq!(out.m[03], 186.97, 1e-5);
        assert_approx_eq!(out.m[04], 24.43, 1e-5);
        assert_approx_eq!(out.m[05], -61.18, 1e-5);
        assert_approx_eq!(out.m[06], 18.84, 1e-5);
        assert_approx_eq!(out.m[07], -53.08, 1e-5);
        assert_approx_eq!(out.m[08], 83.39, 1e-5);
        assert_approx_eq!(out.m[09], 18.72, 1e-5);
        assert_approx_eq!(out.m[10], 87.18, 1e-5);
        assert_approx_eq!(out.m[11], -92.89, 1e-5);
        assert_approx_eq!(out.m[12], -12.94, 1e-5);
        assert_approx_eq!(out.m[13], -2.04, 1e-5);
        assert_approx_eq!(out.m[14], 1.02, 1e-5);
        assert_approx_eq!(out.m[15], 0.970001, 1e-5);
    }

    #[test]
    fn matrix4_add_assign() {
        let val1 = [
            -98.96, 98.99, 72.96, 98.37, -61.17, 6.0, -13.05, 18.62, 43.24, -19.56, 39.17, -19.17,
            -49.98, -36.64, 48.0, 45.27,
        ];
        let val2 = [
            59.09, -8.73, -19.45, 88.6, 85.6, -67.18, 31.89, -71.7, 40.15, 38.28, 48.01, -73.72,
            37.04, 34.6, -46.98, -44.3,
        ];
        let mut m1 = Matrix4::new(&val1);
        let m2 = Matrix4::new(&val2);
        m1 += m2;
        assert_approx_eq!(m1.m[00], -39.87, 1e-5);
        assert_approx_eq!(m1.m[01], 90.26, 1e-5);
        assert_approx_eq!(m1.m[02], 53.51, 1e-5);
        assert_approx_eq!(m1.m[03], 186.97, 1e-5);
        assert_approx_eq!(m1.m[04], 24.43, 1e-5);
        assert_approx_eq!(m1.m[05], -61.18, 1e-5);
        assert_approx_eq!(m1.m[06], 18.84, 1e-5);
        assert_approx_eq!(m1.m[07], -53.08, 1e-5);
        assert_approx_eq!(m1.m[08], 83.39, 1e-5);
        assert_approx_eq!(m1.m[09], 18.72, 1e-5);
        assert_approx_eq!(m1.m[10], 87.18, 1e-5);
        assert_approx_eq!(m1.m[11], -92.89, 1e-5);
        assert_approx_eq!(m1.m[12], -12.94, 1e-5);
        assert_approx_eq!(m1.m[13], -2.04, 1e-5);
        assert_approx_eq!(m1.m[14], 1.02, 1e-5);
        assert_approx_eq!(m1.m[15], 0.970001, 1e-5);
    }

    #[test]
    fn matrix4_sub() {
        let val1 = [
            -20.64, -25.69, -17.56, -97.15, 88.28, 28.07, 65.32, 46.34, 1.19, -66.15, 92.73, -3.68,
            -20.59, 62.21, 73.89, -29.04,
        ];
        let val2 = [
            61.53, 75.87, 44.25, -57.29, -81.46, 97.1, -62.07, -27.39, 34.94, 61.01, 5.92, -71.72,
            90.79, 93.32, -63.03, 45.79,
        ];
        let m1 = Matrix4::new(&val1);
        let m2 = Matrix4::new(&val2);
        let out = m1 - m2;
        assert_approx_eq!(out.m[00], -82.17, 1e-5);
        assert_approx_eq!(out.m[01], -101.56, 1e-5);
        assert_approx_eq!(out.m[02], -61.81, 1e-5);
        assert_approx_eq!(out.m[03], -39.86, 1e-5);
        assert_approx_eq!(out.m[04], 169.73999, 1e-5); //fuck floats
        assert_approx_eq!(out.m[05], -69.03, 1e-5);
        assert_approx_eq!(out.m[06], 127.39, 1e-5);
        assert_approx_eq!(out.m[07], 73.73, 1e-5);
        assert_approx_eq!(out.m[08], -33.75, 1e-5);
        assert_approx_eq!(out.m[09], -127.16, 1e-5);
        assert_approx_eq!(out.m[10], 86.81, 1e-5);
        assert_approx_eq!(out.m[11], 68.04, 1e-5);
        assert_approx_eq!(out.m[12], -111.38, 1e-5);
        assert_approx_eq!(out.m[13], -31.11, 1e-5);
        assert_approx_eq!(out.m[14], 136.92, 1e-5);
        assert_approx_eq!(out.m[15], -74.83, 1e-5);
    }

    #[test]
    fn matrix4_sub_assign() {
        let val1 = [
            -20.64, -25.69, -17.56, -97.15, 88.28, 28.07, 65.32, 46.34, 1.19, -66.15, 92.73, -3.68,
            -20.59, 62.21, 73.89, -29.04,
        ];
        let val2 = [
            61.53, 75.87, 44.25, -57.29, -81.46, 97.1, -62.07, -27.39, 34.94, 61.01, 5.92, -71.72,
            90.79, 93.32, -63.03, 45.79,
        ];
        let mut m1 = Matrix4::new(&val1);
        let m2 = Matrix4::new(&val2);
        m1 -= m2;
        assert_approx_eq!(m1.m[00], -82.17, 1e-5);
        assert_approx_eq!(m1.m[01], -101.56, 1e-5);
        assert_approx_eq!(m1.m[02], -61.81, 1e-5);
        assert_approx_eq!(m1.m[03], -39.86, 1e-5);
        assert_approx_eq!(m1.m[04], 169.73999, 1e-5);
        assert_approx_eq!(m1.m[05], -69.03, 1e-5);
        assert_approx_eq!(m1.m[06], 127.39, 1e-5);
        assert_approx_eq!(m1.m[07], 73.73, 1e-5);
        assert_approx_eq!(m1.m[08], -33.75, 1e-5);
        assert_approx_eq!(m1.m[09], -127.16, 1e-5);
        assert_approx_eq!(m1.m[10], 86.81, 1e-5);
        assert_approx_eq!(m1.m[11], 68.04, 1e-5);
        assert_approx_eq!(m1.m[12], -111.38, 1e-5);
        assert_approx_eq!(m1.m[13], -31.11, 1e-5);
        assert_approx_eq!(m1.m[14], 136.92, 1e-5);
        assert_approx_eq!(m1.m[15], -74.83, 1e-5);
    }

    #[test]
    fn matrix4_mul() {
        let val1 = [
            46.3, 6.5, -84.39, 6.06, 91.72, 78.04, -64.94, 32.07, -59.33, -78.26, 54.08, -73.42,
            -27.12, 4.49, 69.9, 91.19,
        ];
        let val2 = [
            -52.91, 12.02, -58.9, 29.93, -16.45, 78.46, 19.49, 27.82, 63.5, 74.75, 51.43, 8.44,
            15.54, 25.59, 73.89, -9.28,
        ];
        let m1 = Matrix4::new(&val1);
        let m2 = Matrix4::new(&val2);
        let out = m1 * m2;
        assert_approx_eq!(out.m[00], -7821.25048, 1e-5);
        assert_approx_eq!(out.m[01], -5086.56104, 1e-5);
        assert_approx_eq!(out.m[02], -6492.78906, 1e-5);
        assert_approx_eq!(out.m[03], 798.100586, 1e-5);
        assert_approx_eq!(out.m[04], -9761.98535, 1e-5);
        assert_approx_eq!(out.m[05], 3191.89941, 1e-5);
        assert_approx_eq!(out.m[06], -4851.52051, 1e-5);
        assert_approx_eq!(out.m[07], 4070.54907, 1e-5);
        assert_approx_eq!(out.m[08], 6719.66064, 1e-5);
        assert_approx_eq!(out.m[09], -4689.76367, 1e-5);
        assert_approx_eq!(out.m[10], -674.419434, 1e-5);
        assert_approx_eq!(out.m[11], -2815.16724, 1e-5);
        assert_approx_eq!(out.m[12], 7216.80126, 1e-5);
        assert_approx_eq!(out.m[13], 7584.87988, 1e-5);
        assert_approx_eq!(out.m[14], 12017.8643, 1e-5);
        assert_approx_eq!(out.m[15], -943.077087, 1e-5);
    }

    #[test]
    fn matrix4_mul_assign() {
        let val1 = [
            46.3, 6.5, -84.39, 6.06, 91.72, 78.04, -64.94, 32.07, -59.33, -78.26, 54.08, -73.42,
            -27.12, 4.49, 69.9, 91.19,
        ];
        let val2 = [
            -52.91, 12.02, -58.9, 29.93, -16.45, 78.46, 19.49, 27.82, 63.5, 74.75, 51.43, 8.44,
            15.54, 25.59, 73.89, -9.28,
        ];
        let mut m1 = Matrix4::new(&val1);
        let m2 = Matrix4::new(&val2);
        m1 *= m2;
        assert_approx_eq!(m1.m[00], -7821.25048, 1e-5);
        assert_approx_eq!(m1.m[01], -5086.56104, 1e-5);
        assert_approx_eq!(m1.m[02], -6492.78906, 1e-5);
        assert_approx_eq!(m1.m[03], 798.100586, 1e-5);
        assert_approx_eq!(m1.m[04], -9761.98535, 1e-5);
        assert_approx_eq!(m1.m[05], 3191.89941, 1e-5);
        assert_approx_eq!(m1.m[06], -4851.52051, 1e-5);
        assert_approx_eq!(m1.m[07], 4070.54907, 1e-5);
        assert_approx_eq!(m1.m[08], 6719.66064, 1e-5);
        assert_approx_eq!(m1.m[09], -4689.76367, 1e-5);
        assert_approx_eq!(m1.m[10], -674.419434, 1e-5);
        assert_approx_eq!(m1.m[11], -2815.16724, 1e-5);
        assert_approx_eq!(m1.m[12], 7216.80126, 1e-5);
        assert_approx_eq!(m1.m[13], 7584.87988, 1e-5);
        assert_approx_eq!(m1.m[14], 12017.8643, 1e-5);
        assert_approx_eq!(m1.m[15], -943.077087, 1e-5);
    }
}
