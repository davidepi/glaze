#version 460
#extension GL_EXT_ray_tracing : require

layout(location=0) rayPayloadEXT vec3 payload;
layout(push_constant) uniform readonly pc {
  mat4 camera2world;
  mat4 screen2camera;
} Camera;
layout(set=0, binding=0) uniform readonly frameData {
  uint seed;
  uint lights_no;
  vec2 sample_shift;
  bool new_frame;
}FrameData;
layout(set=0, binding=1, rgba32f) uniform image2D accumulate_image;
layout(set=0, binding=2, rgba32f) uniform writeonly image2D result_image;
layout(set=1, binding=0) uniform accelerationStructureEXT scene;

vec3 ray_origin()
{
  // technically this could be just the camera position...
  vec4 origin_screen_space = vec4(0.0, 0.0, 0.0, 1.0);
  vec4 origin = Camera.camera2world * origin_screen_space;
  return origin.xyz;
}

vec3 ray_dir(vec2 ndc)
{
  // take a pixel in screen space (-1.0, 1.0) and calculates the ray in world space
  // by applying the inverse of the transformation matrices usually used in raster rendering

  // note the 1.0 in the Z component. In my other renderer I used 0.0 and that was handled by the
  // raster2screen transformation matrix. Here I don't use such matrix so I need to put the
  // direction in screen space slightly in front of the ray origin (which is on 0.0)
  vec3 target = (Camera.screen2camera*vec4(ndc, 1.0, 1.0)).xyz;
  vec4 direction = normalize(Camera.camera2world * vec4(normalize(target), 0.0));
 return direction.xyz;
}

void main()
{
  if (FrameData.lights_no == 0)
  {
    // not even worth dealing with the accumulation
    imageStore(result_image, ivec2(gl_LaunchIDEXT.xy), vec4(0.0, 0.0, 0.0, 1.0));
    return;
  }
  const vec2 pixel = gl_LaunchIDEXT.xy + FrameData.sample_shift;
  const vec2 uv = pixel / gl_LaunchSizeEXT.xy;
  const vec2 ndc = vec2(-1.0)+2.0*uv;
  vec3 origin = ray_origin();
  vec3 direction = ray_dir(ndc);
  vec4 cumulative_val;
  if(FrameData.new_frame)
  {
    cumulative_val = vec4(0.0);
  }
  else
  {
    cumulative_val = imageLoad(accumulate_image, ivec2(gl_LaunchIDEXT.xy));
  }

  const uint rayFlags = gl_RayFlagsOpaqueEXT;
  const uint cullMask = 0xFF;
  const uint sbtRecordOffset = 0;
  const uint sbtRecordStride = 0;
  const uint missIndex = 0;
  const float tmin = 0.001f;
  const float tmax = 10000.0f;
  const int payloadLocation = 0;

  traceRayEXT(scene,
             rayFlags,
             cullMask,
             sbtRecordOffset,
             sbtRecordStride,
             missIndex,
             origin,
             tmin,
             direction,
             tmax,
             payloadLocation);
  // add result
  cumulative_val.xyz += payload;
  cumulative_val.w += 1.0; // this is the number of samples
  imageStore(accumulate_image, ivec2(gl_LaunchIDEXT.xy), cumulative_val);
  imageStore(result_image, ivec2(gl_LaunchIDEXT.xy), vec4(cumulative_val.xyz/cumulative_val.w, 1.0));
}
