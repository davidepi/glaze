#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier: require

#include "random.glsl"
#include "constants.glsl"
#include "spectrum.glsl"
#include "hit.glsl"
#include "raytrace_structures.glsl"
#include "raytrace_commons.glsl"

layout(location=0) rayPayloadEXT SurfaceHit sh;
layout(location=1) rayPayloadEXT bool shadow_ray_hit;
layout(location=2) callableDataEXT SampledLight sam;
layout(location=3) callableDataEXT BsdfValue bsdfval;
layout(location=4) callableDataEXT BsdfSampleValue bsdfsampleval;

layout(push_constant) uniform readonly pc {
  mat4 camera2world;
  mat4 screen2camera;
} Camera;
layout(set=0, binding=0) uniform readonly frameData {
  uint seed;
  uint lights_no;
  vec2 pixel_offset;
  float scene_radius;
  float exposure;
}FrameData;
layout(set=0, binding=1, rgba32f) uniform image2D accumulate_image;
layout(set=0, binding=2, rgba32f) uniform writeonly image2D result_image;
layout(set=1, binding=0) uniform accelerationStructureEXT scene;
layout(std430, set=1, binding=1) readonly buffer vertexBuffer {
  VertexPacked vertices[];
} VertexBuffer;
layout(std430, set=1, binding=2) readonly buffer indexBuffer {
  Triangle indices[];
} IndexBuffer;
layout(std430, set=1, binding=4) readonly buffer materialBuffer {
  RTMaterial materials[];
} MaterialBuffer;
layout(std430, set=1, binding=5) readonly buffer lightBuffer {
  RTLight lights[];
} LightBuffer;
layout(set=1, binding=6) uniform sampler2D textures[];
layout(set=1, binding=7) readonly buffer derivativeBuffer {
  Derivatives d[];
}DerivativeBuffer;
vec3 ray_origin()
{
  // technically this could be just the camera position...
  vec4 origin_screen_space = vec4(0.0, 0.0, 0.0, 1.0);
  vec4 origin = Camera.camera2world * origin_screen_space;
  return origin.xyz;
}

vec3 ray_dir(vec2 ndc)
{
  // take a pixel in screen space (-1.0, 1.0) and calculates the ray in world space
  // by applying the inverse of the transformation matrices usually used in raster rendering

  // note the 1.0 in the Z component. In my other renderer I used 0.0 and that was handled by the
  // raster2screen transformation matrix. Here I don't use such matrix so I need to put the
  // direction in screen space slightly in front of the ray origin (which is on 0.0)
  vec3 target = (Camera.screen2camera*vec4(ndc, 1.0, 1.0)).xyz;
  vec4 direction = normalize(Camera.camera2world * vec4(normalize(target), 0.0));
  return direction.xyz;
}

Spectrum direct_light(inout uint rng, in vec3 woW, in HitData hit, in ShadingSpace mat, in RTMaterial material)
{
  Spectrum L = SPECTRUM_ZERO;
  // choose a random light to sample
  sam.light_index = uint(min(rand(rng)*FrameData.lights_no, FrameData.lights_no-1));
  sam.position = hit.point;
  RTLight light = LightBuffer.lights[sam.light_index];
  executeCallableEXT(light.shader, 2);
  if(sam.pdf > 0.0)
  {
    bsdfval.woW = woW;
    bsdfval.wiW = sam.wiW;
    bsdfval.geometric_normal = hit.geometric_normal;
    bsdfval.uv = hit.uv;
    bsdfval.shading = mat;
    bsdfval.rand_sample = rand(rng);
    bsdfval.material_index = sh.ids.y;
    executeCallableEXT(material.bsdf_index, 3);
    if (!is_black(bsdfval.value))
    {
      // trace shadow ray
      shadow_ray_hit = true;
      traceRayEXT(scene, gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT,
          0xFF, 0, 0, 1, hit.point, 0.001, sam.wiW, sam.distance-1E-3, 1);
      if (!shadow_ray_hit && bsdfval.pdf > 0.0)
      {
          float adot = abs(dot(bsdfval.wiW, hit.shading_normal))/sam.pdf;
          L = mul(mul(bsdfval.value, sam.emission), adot);
      }
    }
  }
  return mul(L, float(FrameData.lights_no));
}

void main()
{
  if (FrameData.lights_no == 0)
  {
    // not even worth dealing with the accumulation
    imageStore(result_image, ivec2(gl_LaunchIDEXT.xy), vec4(0.0, 0.0, 0.0, 1.0));
    return;
  }
  uint rng = srand(vec3(FrameData.seed, gl_LaunchIDEXT.xy));
  const vec2 pixel = gl_LaunchIDEXT.xy + FrameData.pixel_offset;
  const vec2 uv = pixel / gl_LaunchSizeEXT.xy;
  const vec2 ndc = vec2(-1.0)+2.0*uv;
  vec3 origin = ray_origin();
  vec3 direction = ray_dir(ndc);
  vec4 cumulative_val = imageLoad(accumulate_image, ivec2(gl_LaunchIDEXT.xy));
  Spectrum power = SPECTRUM_ONE;
  Spectrum L = SPECTRUM_ZERO;
  float rrprob = 1.0;
  for(int i=0; i<5; i++)
  {
    traceRayEXT(scene, 0, 0xFF, 0, 0, 0, origin, 0.0001, direction, INFINITY, 0);
    if (sh.miss)
    {
      break;
    }
    HitData hit;
    RTMaterial material;
    EXPAND_HIT(sh, hit, material);
    vec3 woW = -direction;
    ShadingSpace matrix = new_shading_space(hit.dpdu, hit.shading_normal);
    if(material.is_specular==0)
    {
      Spectrum direct = direct_light(rng, woW, hit, matrix, material);
      L = add(L, mul(direct, power));
    }
    if(i>3)
    {
      float term = min(luminance(power), 0.5);
      if(rand(rng) < term || i==4) // don't sample next direction if it's the last iteration
      {
        break;
      }
      else
      {
        rrprob = term;
      }
    }
    bsdfsampleval.uv = hit.uv;
    bsdfsampleval.woW = woW;
    bsdfsampleval.geometric_normal = hit.geometric_normal;
    bsdfsampleval.rand_sample = rand3(rng);
    bsdfsampleval.shading = matrix;
    bsdfsampleval.material_index = sh.ids.y;
    executeCallableEXT(material.bsdf_index+1, 4);
    if(bsdfsampleval.pdf == 0.0 || is_black(bsdfsampleval.value))
    {
      break;
    }
    float adot = abs(dot(bsdfsampleval.wiW, hit.shading_normal));
    float inv = adot/bsdfsampleval.pdf*rrprob;
    power = mul(power, mul(bsdfsampleval.value, inv));
    origin = hit.point;
    direction = bsdfsampleval.wiW;
  }
  cumulative_val.xyz += xyz(L);
  cumulative_val.w += 1.0;
  vec3 rgb = rgb(vec3(cumulative_val.xyz*FrameData.exposure/cumulative_val.w));
  imageStore(accumulate_image, ivec2(gl_LaunchIDEXT.xy), cumulative_val);
  imageStore(result_image, ivec2(gl_LaunchIDEXT.xy), vec4(rgb, 1.0));
}
