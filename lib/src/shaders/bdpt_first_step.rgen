#version 460
#extension GL_EXT_ray_tracing : require

#include "random.glsl"
#include "constants.glsl"
#include "spectrum.glsl"
#include "hit.glsl"
#include "raytrace_structures.glsl"
#include "raytrace_commons.glsl"

layout(location=0) rayPayloadEXT SurfaceHit sh;

layout(push_constant) uniform readonly pc {
  mat4 camera2world;
  mat4 screen2camera;
} Camera;
layout(set=0, binding=0) uniform readonly frameData {
  RTFrameData data;
} FrameData;
layout(std430, set=0, binding=1) writeonly buffer bdpt {
  BDPTPath paths[];
} Bdpt;
layout(set=1, binding=0) uniform accelerationStructureEXT scene;
layout(std430, set=1, binding=5) readonly buffer lightBuffer {
  RTLight lights[];
} LightBuffer;

vec3 ray_origin()
{
  // technically this could be just the camera position...
  vec4 origin_screen_space = vec4(0.0, 0.0, 0.0, 1.0);
  vec4 origin = Camera.camera2world * origin_screen_space;
  return origin.xyz;
}

vec3 ray_dir(vec2 ndc)
{
  // take a pixel in screen space (-1.0, 1.0) and calculates the ray in world space
  // by applying the inverse of the transformation matrices usually used in raster rendering

  // note the 1.0 in the Z component. In my other renderer I used 0.0 and that was handled by the
  // raster2screen transformation matrix. Here I don't use such matrix so I need to put the
  // direction in screen space slightly in front of the ray origin (which is on 0.0)
  vec3 target = (Camera.screen2camera*vec4(ndc, 1.0, 1.0)).xyz;
  vec4 direction = normalize(Camera.camera2world * vec4(normalize(target), 0.0));
  return direction.xyz;
}

void light_omni_gen_photon(in RTLight light, in vec2 rand_sample, out vec3 origin,
                           out vec3 direction, out vec3 normal,
                           out Spectrum radiance, out float pdf_pos, out float pdf_dir)
{
  origin = light.pos.xyz;
  float z = 1.0 - 2.0 * rand_sample.x;
  float r = sqrt(max(0.0, 1.0 - z * z));
  float phi = 2.0 * PI * rand_sample.y;
  direction = vec3(r * cos(phi), r * sin(phi), z);
  normal = direction;
  pdf_pos = 1.0;
  pdf_dir = INV_4PI;
  radiance = Spectrum(light.color0, light.color1, light.color2, light.color3);
}

void light_sun_gen_photon(in RTLight light, in vec2 rand_sample, out vec3 origin,
                          out vec3 direction, out vec3 normal,
                          out Spectrum radiance, out float pdf_pos, out float pdf_dir)
{
  // create a coord system around the light direction (upwards)
  vec3 v1 = -light.dir.xyz;
  vec3 v2a = vec3(-v1.z, 0, v1.x)/sqrt(v1.x*v1.x+v1.z*v1.z);
  vec3 v2b = vec3(0, v1.z, -v1.y)/sqrt(v1.y*v1.y+v1.z*v1.z);
  vec3 v2 = mix(v2b, v2a, step(abs(v1.y), abs(v1.x)));
  // sample a position in the disk with with the previous coordinate system
  vec2 remap = 2.0 * rand_sample - vec2(1.0);
  vec2 xgy = vec2(remap.x, PI_OVER_4*remap.y/remap.x);
  vec2 xly = vec2(remap.y, PI_OVER_2-PI_OVER_4*remap.x/remap.y);
  vec2 disk_sample = mix(xly, xgy, step(abs(remap.y), abs(remap.x)));
  vec3 disk_pos = FrameData.data.scene_radius*(v1*disk_sample.x+v2*disk_sample.y); // scale the disk, still positioned in 0,0,0
  // generate the outgoing ray, by positioning in the world space
  origin = FrameData.data.center_and_bdpt_step.xyz*disk_pos+FrameData.data.scene_radius*-light.dir.xyz;
  direction = light.dir.xyz;
  normal = direction;
  pdf_pos = 1.0/(PI*FrameData.data.scene_radius*FrameData.data.scene_radius);
  pdf_dir = 1.0;
  radiance = Spectrum(light.color0, light.color1, light.color2, light.color3);
}

void main()
{
  if(FrameData.data.lights_no == 0)
  {
    return;
  }
  uint path_id = uint(gl_LaunchIDEXT.y*gl_LaunchSizeEXT.x+gl_LaunchIDEXT.x);
  /// CAMERA PATH ///
  const vec2 pixel = gl_LaunchIDEXT.xy + FrameData.data.pixel_offset;
  const vec2 uv = pixel / gl_LaunchSizeEXT.xy;
  const vec2 ndc = vec2(-1.0)+2.0*uv;
  vec3 origin = ray_origin();
  vec3 direction = ray_dir(ndc);
  traceRayEXT(scene, 0, 0xFF, 0, 0, 0, origin, 0.0001, direction, INFINITY, 0);
  BDPTPathVertex camera_vertex;
  camera_vertex.distance = sh.distance;
  camera_vertex.miss = sh.miss;
  camera_vertex.attribs = sh.attribs;
  camera_vertex.ids = sh.ids;
  camera_vertex.pdf_fwd = 1.0;
  camera_vertex.color0 = vec4(1.0);
  camera_vertex.color1 = vec4(1.0);
  camera_vertex.color2 = vec4(1.0);
  camera_vertex.color3 = vec4(1.0);
  /// LIGHT PATH ///
  uint rng = srand(vec3(FrameData.data.seed, gl_LaunchIDEXT.xy));
  uint light_id = uint(min(rand(rng)*FrameData.data.lights_no, FrameData.data.lights_no-1));
  RTLight light = LightBuffer.lights[light_id];
  float light_pdf = 1.0/FrameData.data.lights_no;
  vec3 normal;
  float pdf_pos;
  float pdf_dir;
  Spectrum radiance;
  if(light.shader == 0)
  {
    light_omni_gen_photon(light, rand2(rng), origin, direction, normal,
                          radiance, pdf_pos, pdf_dir);
  }
  else //if(light.shader == 1)
  {
    light_sun_gen_photon(light, rand2(rng), origin, direction, normal,
                         radiance, pdf_pos, pdf_dir);
  }
  float radiance_weight = abs(dot(normal, direction))/(light_pdf*pdf_pos*pdf_dir);
  radiance = mul(radiance, radiance_weight);
  traceRayEXT(scene, 0, 0xFF, 0, 0, 0, origin, 0.0001, direction, INFINITY, 0);
  BDPTPathVertex light_vertex;
  light_vertex.distance = sh.distance;
  light_vertex.miss = sh.miss;
  light_vertex.attribs = sh.attribs;
  light_vertex.ids = sh.ids;
  light_vertex.pdf_fwd = pdf_dir;
  light_vertex.color0 = radiance.col0;
  light_vertex.color1 = radiance.col1;
  light_vertex.color2 = radiance.col2;
  light_vertex.color3 = radiance.col3;
  /// SAVE RESULTS ///
  Bdpt.paths[path_id].camera[0] = camera_vertex;
  Bdpt.paths[path_id].light[0] = light_vertex;
}
