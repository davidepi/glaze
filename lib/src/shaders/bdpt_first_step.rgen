#version 460
#extension GL_EXT_ray_tracing : require

#include "random.glsl"
#include "constants.glsl"
#include "spectrum.glsl"
#include "hit.glsl"
#include "bdpt_utils.glsl"
#include "raytrace_structures.glsl"
#include "raytrace_commons.glsl"

layout(location=0) rayPayloadEXT SurfaceHit sh;
layout(location=1) callableDataEXT LightPhoton ph;

layout(push_constant) uniform readonly pc {
  mat4 camera2world;
  mat4 screen2camera;
} Camera;
layout(set=0, binding=0) uniform readonly frameData {
  RTFrameData data;
} FrameData;
layout(std430, set=0, binding=1) writeonly buffer bdpt {
  BDPTPath paths[];
} Bdpt;
layout(set=1, binding=0) uniform accelerationStructureEXT scene;
layout(std430, set=1, binding=5) readonly buffer lightBuffer {
  RTLight lights[];
} LightBuffer;

vec3 ray_origin()
{
  // technically this could be just the camera position...
  vec4 origin_screen_space = vec4(0.0, 0.0, 0.0, 1.0);
  vec4 origin = Camera.camera2world * origin_screen_space;
  return origin.xyz;
}

vec3 ray_dir(vec2 ndc)
{
  // take a pixel in screen space (-1.0, 1.0) and calculates the ray in world space
  // by applying the inverse of the transformation matrices usually used in raster rendering

  // note the 1.0 in the Z component. In my other renderer I used 0.0 and that was handled by the
  // raster2screen transformation matrix. Here I don't use such matrix so I need to put the
  // direction in screen space slightly in front of the ray origin (which is on 0.0)
  vec3 target = (Camera.screen2camera*vec4(ndc, 1.0, 1.0)).xyz;
  vec4 direction = normalize(Camera.camera2world * vec4(normalize(target), 0.0));
  return direction.xyz;
}

void main()
{
  if(FrameData.data.lights_no == 0)
  {
    return;
  }
  uint path_id = uint(gl_LaunchIDEXT.y*gl_LaunchSizeEXT.x+gl_LaunchIDEXT.x);
  uint rng = srand(vec3(FrameData.data.seed, gl_LaunchIDEXT.xy));

  /// CAMERA PATH ///
  const vec2 pixel = gl_LaunchIDEXT.xy + FrameData.data.pixel_offset;
  const vec2 uv = pixel / gl_LaunchSizeEXT.xy;
  const vec2 ndc = vec2(-1.0)+2.0*uv;
  vec3 origin = ray_origin();
  vec3 direction = ray_dir(ndc);
  traceRayEXT(scene, 0, 0xFF, 0, 0, 0, origin, 0.0001, direction, INFINITY, 0);
  BDPTPathVertex camera_vertex;
  surface_hit_to_vertex(sh, camera_vertex);
  camera_vertex.pdf_fwd = 1.0;
  camera_vertex.color0 = vec4(1.0);
  camera_vertex.color1 = vec4(1.0);
  camera_vertex.color2 = vec4(1.0);
  camera_vertex.color3 = vec4(1.0);

  /// LIGHT PATH ///
  ph.light_id = uint(min(rand(rng)*FrameData.data.lights_no, FrameData.data.lights_no-1));
  RTLight light = LightBuffer.lights[ph.light_id];
  float light_sel_pdf = 1.0/FrameData.data.lights_no;
  ph.rand_sample = rand2(rng);
  executeCallableEXT(light.shader+1, 1);
  float weight = abs(dot(ph.normal, ph.direction));
  weight /= (light_sel_pdf*ph.pdf_pos*ph.pdf_dir);
  ph.emission = mul(ph.emission, weight);
  traceRayEXT(scene, 0, 0xFF, 0, 0, 0, ph.origin, 0.0001, ph.direction, INFINITY, 0);
  BDPTPathVertex light_vertex;
  surface_hit_to_vertex(sh, light_vertex);
  light_vertex.pdf_fwd = ph.pdf_dir;
  light_vertex.color0 = ph.emission.col0;
  light_vertex.color1 = ph.emission.col1;
  light_vertex.color2 = ph.emission.col2;
  light_vertex.color3 = ph.emission.col3;

  /// SAVE RESULTS ///
  Bdpt.paths[path_id].camera[0] = camera_vertex;
  Bdpt.paths[path_id].origin_camera = vec4(origin, 0.0);
  Bdpt.paths[path_id].last_wo_camera = vec4(-direction, 0.0);
  Bdpt.paths[path_id].light[0] = light_vertex;
  Bdpt.paths[path_id].origin_light = vec4(ph.origin, 0.0);
  Bdpt.paths[path_id].last_wo_light = vec4(-ph.direction, 0.0);
}
